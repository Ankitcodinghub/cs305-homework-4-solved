# cs305-homework-4-solved
**TO GET THIS SOLUTION VISIT:** [CS305 Homework 4 Solved](https://www.ankitcodinghub.com/product/cs305-programming-languages-solved-2/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;109455&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CS305 Homework 4 Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
1 Introduction

In this homework you will implement various Scheme procedures that will hopefully give you a better grasp on the language.

2 Some Helpful Hints

In this section, some useful hints that you can use for debugging purposes are given. However, any imperative features used for debugging purposes need to be removed before submitting the homework.

You will see that in different part of this homework we ask you to produce an error under some conditions. All these errors must be produced by using this error procedure of Scheme. We will catch the error messages generated by the error procedure in our automatic grading script. Therefore it is important that you use the error procedure for producing the error messages. All your error messages should be in the form:

ERROR305: {OPTIONAL ERROR MESSAGE}

This means that all your error messages must start with the keyword ERROR305 followed by a colon followed by an optional error message of your choice.

1 ]=&gt; (define add (lambda (n1 n2)

(if (and (number? n1) (number? n2))

(+ n1 n2)

(error ‚ÄúERROR305: actuals are not numbers‚Äù ))))

1 ]=&gt; (add 3 4) ;Value: 7

1 ]=&gt; (add ‚Äôa 4)

;ERROR305: actuals are not numbers

;To continue, call RESTART with an option number:

; (RESTART 1) =&gt; Return to read-eval-print level 1.

2 error&gt;

1 ]=&gt; (display 5)

5

;Unspecified return value

1 ]=&gt; (define x 3) ;Value: x

1 ]=&gt; (display x)

3

;Unspecified return value

1 ]=&gt; (define x ‚Äô(1 2 a))

;Value: x

1 ]=&gt; (display x)

(1 2 a)

;Unspecified return value

1 ]=&gt; (define add (lambda (n1 n2)

(if (and (number? n1) (number? n2))

(+ n1 n2) (let* (

(dummy1 (if (number? n1)

(display ‚Äú::number::‚Äù)

(display n1))) (dummy2 (if (number? n2)

(display ‚Äú::number::‚Äù)

(display n2)))

)

(error ‚ÄúERROR305: actuals are not numbers‚Äù)))))

;Value add

1]=&gt; (add 3 4) ;Value: 7

1 ]=&gt; (add 3 ‚Äôa )

::number::a

;ERROR305: actuals are not numbers

;To continue, call RESTART with an option number:

; (RESTART 1) =&gt; Return to read-eval-print level 1.

2 error&gt;

Note that let could have been used instead of let*, however, in that case the order of bindings would not be deterministic, hence it would be more difficult to understand which actual parameter caused the problem.

In Scheme, you can comment out parts of the source by using semicolon (;) character. It will comment out the rest of the line. This can be used as a trick for your testing purposes in the following way. Assume that, you are trying to implement the add procedure given above. Rather than directly typing it in the Scheme interpreter, it is easier for the development purposes, to write the code in a separate text file, let‚Äôs say add.scm and then load it into the interpreter. Furthermore, you can also add some test cases at the end of the file. When MIT Scheme interpreter loads a file, it will print the value of the last expression that appears in the input file. More explicitly, let us assume that you have a file named add.scm with the following content:

; Adds to arguments if they are both numbers.

; If a nonnumber argument is seen, it produces

; an error

(define add (lambda (n1 n2)

(if (and (number? n1) (number? n2))

(+ n1 n2) (let* (

(dummy1 (if (number? n1)

(display ‚Äú::number::‚Äù)

(display n1))) (dummy2 (if (number? n2)

(display ‚Äú::number::‚Äù)

(display n2)))

)

(error ‚ÄúERROR305: actuals are not numbers‚Äù)))))

; tests for the procedure add

; (add 3 5)

; (add 4 5)

; (add 4 ‚Äôa)

You can load this file into the interpreter as follows:

1]=&gt; (load ‚Äúadd.scm‚Äù)

;Loading ‚Äúadd.scm‚Äù ‚Äî done

;Value: add

Note that, it prints out a value add, which is the identifier defined by the last expression in the file. Now assume that we have removed the semicolons in front of the (add 3 5) and (add 4 5) in the file add.scm. If we load the file again, here is what will happen:

1]=&gt; (load ‚Äúadd.scm‚Äù)

;Loading ‚Äúadd.scm‚Äù ‚Äî done

;Value: 9

As you see, the value 9 is printed which is the value of the last expression in the file (which is the result of the last expression (add 4 5)). Hence by using comments, you can test your implementation by activating / deactivating some test cases.

3 Triangles

In this homework, you will implement some procedures related to the following concepts on triangles.

Triple: A list of three integers such as (5 4 8). We will use this form of triples to represent triangles. You can think that these numbers as the lengths of the sides of a triangle. For example, the triple (5 4 8) indicates a triangle having sides of length 5, 4, and 8. A triple is sorted if the second element is not smaller than the first element, and the third element is not smaller than the second element. For example (5 4 8) is not a sorted triple, but (4 5 8) is sorted triple, so is (5 5 8).

Triangle rule: The sum of the lengths of any two sides of a triangle must be strictly greater than the third side. For example the triple (15 4 8) does not correspond to a triangle, since we have 4 + 8 &lt; 15.

Pythagorean theorem: The sum of the areas of the two squares on the legs (a and b) equals the area of the square on the hypotenuse (c). a2 + b2 = c2.

4 Flow of the procedures

In terms of the main flow of the program, one input will be given to the main procedure. This input must be a list consisting of arbitrary number of triples and it should not be empty. It is important that you can not make any assumptions about the number of triples in the list. Also, you can not assume anything about the content of the elements in the list. Hence, there should be an input check.

Then, if the input is correct, you should sort the numbers in each of the triples in ascending order. After sorting the numbers, you should filter the triples that satisfy the ‚ÄúTriangle rule‚Äù first and then you should filter the triples that satisfy the ‚ÄúPythagorean theorem‚Äù described in section 3.

In the last step, you should sort the triples (Pythagorean triangles) that you filtered in the previous step according to the areas of the triangles, again in ascending order.

5 Scheme procedures to be implemented

You will implement the following procedures in Scheme. We will represent the triangles as lists of Scheme numbers (triples). For example a triangle will ne represented as the Scheme list of numbers (3 4 5) with three elements where the first element is the number 3, the second element is the number 4 and the third element is again the number 5. In the Scheme procedures to be implemented below, whenever we talk about a ‚Äútriple‚Äù, please assume that it is such a list. In addition, in some of the Scheme procedures you will implement, you will use the list of triples defined in the section 4. Whenever we talk about a ‚ÄútripleList‚Äù, please assume that it is such a list. The procedures to be implemented are really easy. You can define helper procedures to be used in your code. You can also use the procedure main-procedure defined below to understand the flow of the program and the error procedure introduced above to produce the errors. However, do not use any built-in procedure other than the ones we‚Äôve covered in our lecture notes. Below is the list of procedures to be implemented:

;- Procedure: main-procedure

;- Input : Takes only one parameter named tripleList ;- Output : Returns list of triples according to the scenario ; described in section 3.

; Returns an error if the given parameter is not a tripleList. (define main-procedure

(lambda (tripleList)

(if (or (null? tripleList) (not (list? tripleList)))

(error ‚ÄúERROR305: the input should be a list full of triples‚Äù) (if (check-triple? tripleList)

(sort-area (filter-pythagorean (filter-triangle

(sort-all-triples tripleList))))

(error ‚ÄúERROR305: the input should be a list full of triples‚Äù)

)

)

)

)

;- Procedure: check-triple?

;- Input : Takes only one parameter named tripleList

;- Output : Returns true if the given parameter consists of triples, ; returns false if otherwise.

;- Hint: You can assume that the given input to this procedure is ; a list and it is not null.

;- Examples :

; (check-triple? ‚Äô((1 2) (3 4 5))) ‚Äî‚Äî&gt; evaluates to false since ‚Äô(1 2) has only 2 elements

; (check-triple? ‚Äô((5 12 12) (6 6 6) ())) ‚Äî-&gt; evaluates to false since ‚Äô() is empty

; (check-triple? ‚Äô((5 3 9) (9 55 32) (‚Äôa 28 67))) ‚Äî‚Äì&gt; evaluates to false since ‚Äôa is not a number

; (check-triple? ‚Äô((5 12 13) (3 4 5) (16 63 65) (12 35 37))) ‚Äì&gt; evaluates to true (define check-triple?

(lambda (tripleList) ‚Ä¶

)

)

;- Procedure: check-length?

;- Input : Takes two parameters as inTriple and count ;- Output : Returns true if the length of the given list ; equals to count, returns false if otherwise.

;- Hint: You can assume that the given input (inTriple) to this procedure is ; a list.

;- Examples :

; (check-length? ‚Äô(‚Äôa ‚Äôbc) 2) ‚Äì&gt; evaluates to true

; (check-length? ‚Äô(3 4 5) 3) ‚Äì&gt; evaluates to true

; (check-length? ‚Äô(2 3 4 5) 3) ‚Äì&gt; evaluates to false since the length of the list is not 3

; (check-length? ‚Äô(3 4 5) 4) ‚Äì&gt; evaluates to false since the length of the list is not 4

(define check-length?

(lambda (inTriple count) ‚Ä¶

)

)

;- Procedure: check-sides?

;- Input : Takes only one parameter named inTriple

;- Output : It returns true if all of the elements in the given ; list are numbers and each of the numbers is greater than zero.

; It returns false if otherwise.

;- Hint: You can assume that the given input to this procedure is ; a list and it has 3 elements.

;- Examples :

; (check-sides? ‚Äô(6 4 27)) ‚Äì&gt; evaluates to true

; (check-sides? ‚Äô(6 0 27)) ‚Äì&gt; evaluates to false since not all

; elements are greater than 0

; (check-sides? ‚Äô(() ‚Äôc 3)) ‚Äî‚Äî-&gt; evaluates to false since

; ‚Äô() and ‚Äôc are not numbers

; (check-sides? ‚Äô(#t 10 14)) ‚Äî‚Äî-&gt; evaluates to false since #t is not a number (define check-sides?

(lambda (inTriple) ‚Ä¶

)

)

;- Procedure: sort-all-triples

;- Input : Takes only one parameter named tripleList

;- Output : Returns the list of triples given as the parameter in which ; all triples are sorted internally in ascending order. ;- Hint: You can assume that the given input to this procedure is ; a list of triples (see section 4).

;- Examples :

; (sort-all-triples ‚Äô((4 3 5) (9 4 6) (13 12 1) (6 6 6))) ‚Äì&gt; evaluates to

; ((3 4 5) (4 6 9) (1 12 13) (6 6 6))

; (sort-all-triples ‚Äô((4 7 9) (15 36 9))) ‚Äì&gt; evaluates to ((4 7 9) (9 15 36)) (define sort-all-triples (lambda (tripleList) ‚Ä¶

)

)

;- Procedure: sort-triple

;- Input : Takes only one parameter named inTriple

;- Output : It returns the sorted inTriple in ascending order.

;- Hint: You can assume that the given input to this procedure is ; a triple (see section 3).

;- Examples :

; (sort-triple ‚Äô(4 3 5)) ‚Äì&gt; evaluates to (3 4 5)

; (sort-triple ‚Äô(8 8 8)) ‚Äî‚Äî-&gt; evaluates to (8 8 8)

; (sort-triple ‚Äô(6 10 14)) ‚Äî‚Äî-&gt; evaluates to (6 10 14) (define sort-triple (lambda (inTriple) ‚Ä¶

)

)

;- Procedure: filter-triangle

;- Input : Takes only one parameter named tripleList

;- Output : It returns tripleList consists of triples that each triple represents ; a triangle. So, it filters triangles in intripleList and discards other triples.

; The Triangle rule is explained in section 3.

;- Hint: You can assume that the given input to this procedure is

; a list of triples that each of the triples is sorted internally in ascending order.

;- Examples :

; (filter-triangle ‚Äô((3 4 5) (4 6 9) (1 12 13))) ‚Äì&gt; evaluates to ((3 4 5) (4 6 9))

; (filter-triangle ‚Äô((8 10 21) (22 31 53))) ‚Äì&gt; evaluates to () (define filter-triangle (lambda (tripleList) ‚Ä¶

))

;- Procedure: triangle?

;- Input : Takes only one parameter named triple

;- Output : It returns true if the given triple satisfies the triangle rule, ; returns false if otherwise.

; The Triangle rule is explained in section 3.

;- Hint: You can assume that the given input to this procedure is

; a triple (see section 3) in which all elements are sorted in ascending order.

;- Examples :

; (triangle? ‚Äô(4 6 8)) ‚Äî&gt; evaluates to #t

; (triangle? ‚Äô(12 21 34)) ‚Äî&gt; evaluates to #f ; (triangle? ‚Äô(9 10 18)) ‚Äî&gt; evaluates to #t (define triangle?

(lambda (triple) ‚Ä¶

)

)

;- Procedure: filter-pythagorean

;- Input : Takes only one parameter named tripleList

;- Output : It returns tripleList consists of triples that each triple represents ; a pythagorean triangle. So, it filters pythagorean triangles in intripleList ; and discards other triples.

; The Pythagorean theorem is explained in section 3.

;- Hint: You can assume that the given input to this procedure is

; a list of triples that each of the triples is sorted internally in ascending order, ; and satisfies the Triangle rule (see section 3).

;- Examples :

; (filter-pythagorean ‚Äô((3 4 5) (4 6 8))) ‚Äî&gt; evaluates to ((3 4 5))

; (filter-pythagorean ‚Äô((3 4 5) (13 18 30) (5 12 13) (8 8 8))) ‚Äî&gt; evaluates to ((3 4 5) (5 12 13))

; (filter-pythagorean ‚Äô((7 11 16) (9 11 12))) ‚Äî‚Äî‚Äì&gt; evaluates to () (define filter-pythagorean (lambda (tripleList) ‚Ä¶

)

)

;- Procedure: pythagorean-triangle?

;- Input : Takes only one parameter named triple

;- Output : It returns true if the given triple satisfies the Pythagorean theorem, ; returns false if otherwise.

; The Pythagorean theorem is explained in section 3.

;- Hint: You can assume that the given input to this procedure is

; a triple (see section 3) in which all elements are sorted in ascending order.

; Also, the triple itself satisfies the Triangle rule.

;- Examples :

; (pythagorean-triangle? ‚Äô(4 6 8)) ‚Äî&gt; evaluates to #f

; (pythagorean-triangle? ‚Äô(5 12 13)) ‚Äî&gt; evaluates to #t

; (pythagorean-triangle? ‚Äô(7 24 25)) ‚Äî&gt; evaluates to #t

; (pythagorean-triangle? ‚Äô(9 10 18)) ‚Äî&gt; evaluates to #f (define pythagorean-triangle? (lambda (triple) ‚Ä¶

)

)

;- Procedure: sort-area

;- Input : Takes only one parameter named tripleList

;- Output : Returns the list of triples given as the parameter in which ; all triples are sorted according to the areas of the pythagorean triangles ; in ascending order.

;- Hint: You can assume that the given input to this procedure is

; a list of triples that each of the triples is sorted internally in ascending order, ; and satisties the Pythagorean theorem (see section 3).

; Examples :

; (sort-area ‚Äô((5 12 13) (3 4 5) (16 63 65) (12 35 37))) ‚Äì&gt; evaluates to

((3 4 5) (5 12 13) (12 35 37) (16 63 65))

; (sort-area ‚Äô((5 12 13) (16 63 65) (3 4 5))) ‚Äî‚Äî&gt; evaluates to

((3 4 5) (5 12 13) (16 63 65))

(define sort-area (lambda (tripleList) ‚Ä¶

)

)

;- Procedure: get-area

;- Input : Takes only one parameter named triple

;- Output : It returns the area of the given pythagorean triangle.

;- Hint: You can assume that the given input to this procedure is

; a triple (see section 3) in which all elements are sorted in ascending order.

; Also, the triple itself satisfies the Pythagorean theorem (see section 3).

;- Examples :

; (get-area ‚Äô(3 4 5)) ‚Äî‚Äî‚Äî&gt; evaluates to 6

; (get-area ‚Äô(5 12 13)) ‚Äî‚Äî-&gt; evaluates to 30

; (get-area ‚Äô(12 35 37)) ‚Äî‚Äî&gt; evaluates to 210 (define get-area

(lambda (triple) ‚Ä¶

)

)

6 Rules

You can use let* (or other imperative constructs) for debugging purposes as explained in Section 2. However, you are not allowed to use such features for the actual computation as it provides sequential statement execution. The reason is that, you should get used to the functional way of thinking while using a functional programming language.

Remove any occurrence of these imperative features before submitting your homework.

7 How to Submit

Submit your Scheme file named as username-hw4.scm where username is your SUCourse+ username. We will test your submissions in the following manner. A set of test cases will be created to asses the correctness of your scheme procedures. Each test case will be automatically appended to your file. Then the following command will be executed to generate an output. Then your output will be compared against the desired output.

scheme &lt; username-hw4.scm

So, make sure that the above command is enough to produce the desired output.

8 Notes

Important: Name your files as you are told and don‚Äôt zip them. [-10 points

otherwise]

Important: Make sure your procedure name are exactly the same as it is supposed to be!

Important: Since this homework is evaluated automatically make sure your output is exactly as it is supposed to be.

No homework will be accepted if it is not submitted using SUCourse+.

Start working on the homework immediately.

Start working on the homework immediately.

‚Äì Your homework grade will be decided by multiplying what you get from the test cases by a ‚Äúsubmission time factor (STF)‚Äù.

‚Äì If you submit late, you will lose 0.01 of your STF for every 5 mins of delay.

‚Äì SUCourse+‚Äôs timestamp will be used for STF computation.

‚Äì If you submit multiple times, the last submission time will be used.
